package lsi.noc.argus;

import java.lang.Integer;
import java.util.StringTokenizer;
import ptolemy.data.Token;
import ptolemy.data.StringToken;
import ptolemy.kernel.CompositeEntity;
import ptolemy.kernel.util.IllegalActionException;
import ptolemy.kernel.util.NameDuplicationException;
import ptolemy.actor.TypedAtomicActor;
import ptolemy.actor.TypedIOPort;
import ptolemy.data.RecordToken;
import ptolemy.data.IntToken;
import ptolemy.data.LongToken;
import ptolemy.data.expr.Parameter;
import ptolemy.data.type.Type;
import ptolemy.data.type.BaseType;
import ptolemy.data.type.RecordType;
import ptolemy.data.BooleanToken;

/**
 * 
 * Transaction-Level Model Producer. <br>
 * Read input files of the NoC (these files are usually generated by the Atlas
 * tool <link> http://www.inf.pucrs.br/~gaph/AtlasHtml/AtlasIndex_us.html
 * </link> ) and is responsible to transform the packets into tokens. These
 * tokens are sent to the NoC model.<br>
 * <br>
 * 
 * Copyright (c) 2007 - All rights reserved. <br>
 * 
 * @author Leandro Soares Indrusiak
 * @author Luciano Ost
 * @author Leandro Möller
 * @version Argus (Darmstadt, 12.08.2008)
 */
public class TLMProducer extends TypedAtomicActor {

	// public parameters of the producer
	public Parameter prodX, prodY; // position of the producer on the 2D mesh
	private int sourceX, sourceY; // position of the producer on the 2D mesh in
									// Integer

	// state machine definition
	static final int INACTIVE = 0;
	static final int REQUESTING = 1;
	static final int HEADER = 2;
	static final int SIZE = 3;
	static final int PAYLOAD = 4;
	private int state = INACTIVE;

	// module ports
	public TypedIOPort data_out, ack_tx, data_in, read_packet, end_of_file;

	// time variables
	private long timestamp, current_time;

	// packet variables
	private int size, flitCounter, x, y;
	private String packet, address;

	// general variables
	private boolean end;
	private String[] labels;
	private StringTokenizer st;
	private Token[] values;

	public TLMProducer(CompositeEntity container, String name)
			throws NameDuplicationException, IllegalActionException {

		super(container, name);

		// instantiates the parameters that hold the grid position of this
		// instance
		// on the 2D mesh
		prodX = new Parameter(this, "prodX");
		prodX.setTypeEquals(BaseType.INT);
		prodY = new Parameter(this, "prodY");
		prodY.setTypeEquals(BaseType.INT);

		// module ports
		ack_tx = new TypedIOPort(this, "act_tx", true, false);
		ack_tx.setTypeEquals(BaseType.BOOLEAN);
		data_out = new TypedIOPort(this, "data_out", false, true);
		data_in = new TypedIOPort(this, "data_in", true, false);
		end_of_file = new TypedIOPort(this, "end_of_file", true, false);
		end_of_file.setTypeEquals(BaseType.BOOLEAN);
		read_packet = new TypedIOPort(this, "read_packet", false, true);
		read_packet.setTypeEquals(BaseType.BOOLEAN);

		_attachText("_iconDescription", "<svg>\n"
				+ "<rect x=\"0\" y=\"0\" width=\"46\" "
				+ "height=\"80\" style=\"fill:blue\"/>\n" + "</svg>\n");

		// token contents
		labels = new String[9];
		Type[] types = new Type[9];

		// label fields of the token
		labels[0] = "x";
		labels[1] = "y";
		labels[2] = "size";
		labels[3] = "payload";
		labels[4] = "timestamp_ini";
		labels[5] = "timestamp_sent";
		labels[6] = "buffer_size";
		labels[7] = "source_x";
		labels[8] = "source_y";

		// type fields of the token
		types[0] = BaseType.INT;
		types[1] = BaseType.INT;
		types[2] = BaseType.INT;
		types[3] = BaseType.INT;
		types[4] = BaseType.LONG;
		types[5] = BaseType.LONG;
		types[6] = BaseType.INT;
		types[7] = BaseType.INT;
		types[8] = BaseType.INT;

		// setting the token type accepted by the output port of the producer
		RecordType declaredType = new RecordType(labels, types);
		data_out.setTypeEquals(declaredType);
	}

	/**
	 * Method called once by the director when simulation starts; responsible to
	 * initialize variables and state machines.
	 */
	public void initialize() throws IllegalActionException {
		super.initialize();
		// request a packet from the LineReader actor
		read_packet.send(0, BooleanToken.TRUE);
		// go to requesting state
		state = REQUESTING;

		// address of this producer in the 2D mesh
		sourceX = ((IntToken) prodX.getToken()).intValue();
		sourceY = ((IntToken) prodY.getToken()).intValue();
	}

	/**
	 * According to the router, reads lines from input files, prepare tokens and
	 * send the tokens.
	 * 
	 * @exception IllegalActionException
	 *                if there is no director.
	 */
	public boolean prefire() throws IllegalActionException {
		// request state
		if (state == REQUESTING) {
			// if there is an end of file token from the LineReader
			// ps: every time a line is read from file, an end_of_file token is
			// sent saying if it is the end_of_file
			if (end_of_file.hasToken(0)) {
				// get the end of file value
				end = ((BooleanToken) end_of_file.get(0)).booleanValue();
				// if a line token has arrived
				if (data_in.hasToken(0)) {
					// get the line token as a string
					packet = ((StringToken) data_in.get(0)).stringValue();
					// break the string in tokens
					st = new StringTokenizer(packet, " ");
					// initialize the number of flits read from this packet
					flitCounter = 0;
					// get the time to send the packet to the NoC
					timestamp = Long.parseLong(st.nextToken(), 16);
					// get the target address
					address = st.nextToken();
					// capture the XY coordinates of the target from the
					// received string
					if (address.length() > 2) {
						x = Integer.valueOf(address.substring(2, 3)).intValue();
						y = Integer.valueOf(address.substring(3, 4)).intValue();
					} else {
						x = (int) address.charAt(0) - (int) '0';
						y = (int) address.charAt(1) - (int) '0';
					}
					// get the packet size
					size = Integer.parseInt(st.nextToken(), 16);
					// add four flits to be compatible with the Atlas tool and
					// Hermes simulations.
					// This four flits are used in Hermes to send the timestamp
					// that packet entered in the NoC.
					// We are not using it here because it is easier just to
					// insert this information
					// in another field of the record token.
					size = size + 4;

					// create header token
					values = new Token[9];
					values[0] = new IntToken(x);
					values[1] = new IntToken(y);
					values[2] = new IntToken(size);
					values[3] = new IntToken();
					values[4] = new LongToken(timestamp);
					values[5] = new LongToken();
					values[6] = new IntToken(-1);
					values[7] = new IntToken(sourceX);
					values[8] = new IntToken(sourceY);

					// get current time
					current_time = (long) getDirector().getModelTime()
							.getDoubleValue();

					// go to waiting fire state
					state = HEADER;

					// if the packet should not be sent now, schedule the
					// producer to wake up in the future
					if (timestamp > current_time)
						getDirector().fireAt(this,
								(getDirector().getModelTime()).add(timestamp));
				}
			}
		}
		return true;
	}

	/**
	 * Read one traffic file from the input port, disassembly the package and
	 * send its flits to the output ports. If the input does not have a token,
	 * suspend firing and return.
	 * 
	 * @exception IllegalActionException
	 *                If there is no director.
	 */
	public void fire() throws IllegalActionException {

		// getting current time
		current_time = (long) getDirector().getModelTime().getDoubleValue();

		if (state == HEADER) {
			// if current time is equal or greater than the expected to send the
			// packet, send it!
			if (current_time >= timestamp) {
				// convert the string flit into an integer
				int payload = Integer.parseInt(address, 16);
				// put the flit in the record token
				values[3] = new IntToken(payload);
				// put the timestamp time the packet is being sent
				values[5] = new LongToken(current_time);
				// send the header token
				data_out.send(0, new RecordToken(labels, values));
				// go to disassembly state
				state = SIZE;
			}
		} else if (state == SIZE) {
			// if ack token has arrived
			if (ack_tx.hasToken(0)) {
				// put the flit in the record token
				values[3] = new IntToken(size);
				// get the ack token
				BooleanToken acktx = (BooleanToken) ack_tx.get(0);
				// if it is an ACK
				if (acktx.booleanValue()) {
					// go to SENDING state
					state = PAYLOAD;
				}
				// send the size token
				data_out.send(0, new RecordToken(labels, values));
			}
		} else if (state == PAYLOAD) {
			// if ack token has arrived
			if (ack_tx.hasToken(0)) {
				// get the ack token
				BooleanToken acktx = (BooleanToken) ack_tx.get(0);
				// if it is an ACK
				if (acktx.booleanValue()) {
					// if it is not the last four flit of a packet (timestamp),
					// send it normally
					if (flitCounter < (size - 4)) {
						// convert the string flit into an integer
						int payload = Integer.parseInt(st.nextToken(), 16);
						// put the flit in the record token
						values[3] = new IntToken(payload);
						// send the token
						data_out.send(0, new RecordToken(labels, values));
						// increment the number of flits sent
						flitCounter++;
					}
					// if it the last four flits of a packet, send just zeros
					else if (flitCounter < size) {
						// put zeros in the flit information
						values[3] = new IntToken("0000");
						// send the token
						data_out.send(0, new RecordToken(labels, values));
						// increment the number of flits sent
						flitCounter++;
					}
					// if it is the last flit of the packet, but not the last
					// packet to be sent
					else if ((flitCounter == size) && (end == false)) {
						// read another packet
						read_packet.send(0, BooleanToken.TRUE);
						// go to requesting state
						state = REQUESTING;
					}
					// if it is the last flit of the last packet to send
					else if ((flitCounter == size) && (end == true)) {
						// go to inactive state
						state = INACTIVE;
					}
				}// if it is a nack
				else {
					// send the same token again
					data_out.send(0, new RecordToken(labels, values));
				}
			}
		}// end state machine
	}// end fire

	/**
	 * 
	 * @return the X address of this producer
	 * @throws IllegalActionException
	 */
	public int getX() throws IllegalActionException {
		return sourceX;
	}

	/**
	 * 
	 * @return the y address of this producer
	 * @throws IllegalActionException
	 */
	public int getY() throws IllegalActionException {
		return sourceY;
	}

}